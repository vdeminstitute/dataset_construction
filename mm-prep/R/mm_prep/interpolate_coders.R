#!/usr/bin/env Rscript

# ==========================================================================
# The MM expects a variable specific file with a number of
# wide-formatted matrices where country-dates are rows and coders are
# columns. We start here with the raw rds files generated by `split.R`
# and then:
#    1. Transform from long to wide
#    2. Interpolate if not ELS variable
#    3. Add 1 so that we're 1-indexed
#
# Interpolation is a pretty expensive operation so we use
# data.table for the speed.
# ==========================================================================

options(warn = 2)
suppressMessages(library(data.table))
suppressMessages(library(dplyr))
suppressMessages(library(dbplyr))
suppressMessages(library(magrittr))
suppressMessages(library(vutils))
set_env(MODULE_NAME = "interpolate_coders")

#
# Functions
# --------------------------------------------------------------------------

# what obs are lateral?
define_lateral <- function(df, coder_table) {
    lateral_coders <- filter(coder_table, lateral == TRUE) %>%
        select(coder_id, country_id)
    return(semi_join(df, lateral_coders, by = c("coder_id", "country_id")))
}

remove_lateral_only_coders <- function(df, coder_table) {
    lat_only <- 
        coder_table %>%
        group_by(coder_id) %>%
        filter(all(lateral)) %>%
        ungroup %$% coder_id    
    return(filter(df, !coder_id %in% lat_only))
}

to_wide_form <- function(df, ctable) {
    df %<>%
        filter(!is.na(code)) %>%
        mutate(country_text_id = to_ctext_ids(country_id, ctable)) %>%
        select(question_id, country_text_id, historical_date, coder_id, code,
           confidence)

    stopifnot(!any(df$code < 0))
    # If we have a NA then we have a problem, contact Houston.
    with(df,
        stopifnot(!anyNA(c(confidence, code, historical_date,
                       coder_id, question_id))))
    stopifnot(
        no_duplicates(df, c("question_id", "country_text_id", "historical_date",
                   "coder_id")))

    wide.df <- dcast(as.data.table(df),
                 question_id + country_text_id + historical_date ~ coder_id,
                 value.var = c("code", "confidence"), fill = NA) %>%
        as.data.frame(stringsAsFactors = FALSE) %>%
        arrange(country_text_id, historical_date) %>%
        mutate(year = to_year(historical_date)) %>%
        select(-question_id)

    return(wide.df)
}

interpolate_df <- function(df) {
    stopifnot(c("country_text_id", "year", "historical_date") %in% names(df))
    stopifnot(is.data.frame(df))
    stopifnot(!is.character(df[["historical_date"]]), !is.na(as.Date(df[["historical_date"]], format = "%Y-%m-%d")))

    bad_country_years <- as.data.table(df)[, list(country_text_id, historical_date, year)][
                order(country_text_id, historical_date), helper := substr(historical_date[.N], 5, 10),
                    by = c("country_text_id", "year")][helper != "-12-31",][
                , unique(.SD[, c("country_text_id", "year")])][, as.data.frame(.SD)]

    df_yes1231 <- dplyr::anti_join(df,
                      bad_country_years, by = c("country_text_id", "year"))

    dates <- df_yes1231$historical_date
    dt <- data.table::as.data.table(df_yes1231)

    newdt <- dt[,vutils:::interpolate.data.frame(.SD),
                by = list(country_text_id, year),
               .SDcols = names(dt)[!names(dt) %in%
                c("country_text_id", "year", "historical_date")]]

    df_yes1231 <- as.data.frame(newdt, stringsAsFactors = F)
    stopifnot(nrow(df_yes1231) == length(dates))
    df_yes1231 %<>%
        dplyr::mutate(historical_date = dates) %>%
        dplyr::select(country_text_id, historical_date, year,
            dplyr::everything())

    df <- as.data.table(df)
    bad_country_years <- as.data.table(bad_country_years)

    df_no1231 <- df[bad_country_years, on = c("country_text_id", "year"), nomatch = 0][,
        c(
            list(historical_date = historical_date),
            lapply(.SD, locf)
            ), by = c("country_text_id", "year"), .SDcols = grep("\\d+", names(df))][,
        as.data.frame(.SD)]

    dplyr::bind_rows(df_yes1231, df_no1231) %>% 
        dplyr::arrange(country_text_id, historical_date) %>%
        select(country_text_id, historical_date, everything())
}

locf_helper <- function(v) {
    # if all in the next year are NA return vector
    if (all(is.na(v[2:length(v)])))
        return(v)
    locf(v)
}

interpolate_across_years <- function(df) {
    dt <- as.data.table(df)
    dt <- dt[, year := to_year(historical_date)][grepl("-12-31$", historical_date), year_appended := year + 1][,
        year_appended := fifelse(is.na(year_appended), year, year_appended)][, n_obs := .N, by = list(country_text_id, year_appended)]

    # we would like to split the dataset into two parts by the minimum requirement for interpolation:
    # we interpolate only for the cases where there're more than 1 observation per year
    not_interpolate <- dt[n_obs < 2,]
    to_interpolate <- dt[n_obs > 1,][order(country_text_id, historical_date),] # ordering is important, since locf works in a certain way!

    interpolated <- to_interpolate[, 
        c(list(historical_date = historical_date),
            list(year = year),
            lapply(.SD, locf_helper)),
        by = list(country_text_id, year_appended), 
        .SDcols = grep("\\d+", names(dt), value = TRUE)]

    df <- not_interpolate[, n_obs := NULL][, rbind(.SD, interpolated)][order(country_text_id, historical_date),][,
        year_appended := NULL][, as.data.frame(.SD, stringsAsFactors = FALSE)]
    return(df)
}

interpolate_steps <- function(df) {
    df %>%
        interpolate_df %>%
        interpolate_across_years %>%
        return(.)
}

interpolate_wide <- function(wide.df, qtable, VARNAME) {
    ELS <- filter(qtable, name == VARNAME) %>% 
        pull(date_specific) %>%
        grepl("Election-specific dates[.]|Election-specific dates \\(v2eltype\\)[.]", x = .)

    stopifnot(length(ELS) == 1)

    if (ELS) {
        info("We found an ELS variable!")
    } else {
        wide.df <- interpolate_steps(wide.df)
    }
    return(wide.df)
}

wide_to_matrices <- function(wide.df, qtable, VARNAME, vig = FALSE) {
    stopifnot(all(c("country_text_id", "historical_date") %in% names(wide.df)))
    qtable %<>% filter(name == VARNAME)

    if (vig) {
        country_dates <- paste0("A_", wide.df$country_text_id, " ", wide.df$historical_date)
    } else {
        country_dates <- paste(wide.df$country_text_id, wide.df$historical_date)
    }
    wdata <- select(wide.df, dplyr::matches("code")) %>% data.matrix
    conf_mat <- select(wide.df, dplyr::matches("confidence")) %>% data.matrix

    # Self-reported confidences are from 0 - 100; MM expects 0 - 1.
    conf_mat <- conf_mat / 100

    # MM data should be 1-indexed so add 1; however, we don't do this for
    # percentage variables since they will be bootstrapped. Postgres
    # inserts -1 for missingness though so replace with NA.
    if (isTRUE(qtable$question_type != "R") & !vig) {
        wdata <- wdata + 1
    } else {
        missing <- wdata == -1

        is.na(wdata) <- missing
        is.na(conf_mat) <- missing
    }

    colnames(wdata) <- sub("code_", "", colnames(wdata))
    rownames(wdata) <- country_dates

    colnames(conf_mat) <- sub("confidence_", "", colnames(conf_mat))
    rownames(conf_mat) <- country_dates

    return(list(wdata = wdata, conf_mat = conf_mat, country_dates = country_dates))
}

main <- function(df, qtable, coder_table, ctable, VARNAME) {
    
    # Remove if a coder has only lateral scores for this question
    df %<>% remove_lateral_only_coders(coder_table)

    # Lateral scores
    lateral_df <- define_lateral(df, coder_table)
    if (nrow(lateral_df) > 0) {
        # Regular and lateral scores on lateral dates transformed to matrices
        lateral_vign <- 
            semi_join(df, distinct(lateral_df, country_id, historical_date),
                by = c("country_id", "historical_date")) %>%
            to_wide_form(ctable) %>%
            wide_to_matrices(., qtable, VARNAME, vig = TRUE)
    } else {lateral_vign <- NULL}
    

    interpolated_list <- 
        anti_join(df, lateral_df, by = "id") %>%
        to_wide_form(ctable) %>%
        interpolate_wide(., qtable, VARNAME) %>%
        wide_to_matrices(., qtable, VARNAME)
    interpolated_list[["lateral_as_vignettes"]] <- lateral_vign
    return(interpolated_list)
}

#
# Run functions
# --------------------------------------------------------------------------
if (no_test()) {
    # Global variables
    get_globals()

    # Imports
    qtable <- load_qtable()
    ctable <- load_country()

    objs <- find_dep_files(TASK_ID, DB)
    coder_table <- objs[[VARNAME %^% "_coder_table"]][[VARNAME]]
    module_name <- names(objs)[!names(objs) %in% {VARNAME %^% "_coder_table"}]
    df <- objs[[module_name]][[VARNAME]]
    

    # Run
    collectedInputs <- named_list(df, qtable, coder_table, ctable, VARNAME)
    do.call(main, collectedInputs) %>%
        list(.) %>%
        setNames(VARNAME) %>%
        write_file(., OUTFILE, dir_create = TRUE)
    info("Done interpolating " %^% VARNAME)
} else {
    testthat::test_file("~/proj/mm-prep/tests/mm-prep/interpolate_coders_tests.R")
}
update_task_status(db = DB)

